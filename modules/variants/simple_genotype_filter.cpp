#include "modules/variants/simple_genotype_filter.h"

#include "modules/variants/scaffold.h"

namespace variants {

constexpr bool k_gt_dbg = false;

void simple_genotype_filter::discard(assembly_ptr a) {
  // TODO(nils): Fix genotyping for pop tracer
  if (a->tags.contains("POP")) {
    if (assembly_needs_trace(*a)) {
      std::cout << "simple genotype filter passing untouched assembly from pop tracer: " << *a << "\n";
    }
    m_output->add(std::move(a));
    return;
  }
  if (assembly_needs_trace(*a)) {
    std::cout << "simple genotype filter discarding " << *a << "\n";
  }
  if (m_options.report_genotype_discard_func) {
    std::vector<const assembly*> better;
    m_options.report_genotype_discard_func(m_options, *a, better);
  }
}

void simple_genotype_filter::on_assembly(assembly_ptr a) {
  bool trace_this = k_gt_dbg || assembly_needs_trace(*a);

  if (a->tags.contains("BIDIR")) {
    if (trace_this) {
      std::cout << *a << " generated by BIDIR; no genotyping done\n";
    }
    m_output->add(std::move(a));
    return;
  }
  
  if (a->matches_reference) {
    if (trace_this) {
      std::cout << "Assembly matches reference entirely; discarding: " << *a << "\n";
    }
    return;
  }

  if (!m_options.simple_genotype_filter) {
    if (trace_this) {
      std::cout << "Skipping genotyping on assembly due to disabled simple genotype filter: "
                << *a << "\n";
    }
    m_output->add(std::move(a));
    return;
  }

  CHECK(!a->coverage.empty()) << *a;

  int min_depth = container_min(a->coverage);

  int min_pair_depth = 0;
  double avg_pair_depth = 0;
  if (!a->pair_coverage.empty()) {
    min_pair_depth = container_min(a->pair_coverage);
    int tot_pair_depth = 0;
    for (int cov : a->pair_coverage) {
      tot_pair_depth += cov;
    }
    avg_pair_depth = tot_pair_depth * 1. / a->pair_coverage.size();
  }

  if (trace_this) {
    std::cout << "Min depth " << min_depth << " min pair depth " << min_pair_depth
              << " avg pair depth " << avg_pair_depth << " for assembly "
              << dump_assembly_and_vars(*a) << "\n";
  }

  if (avg_pair_depth < m_options.min_avg_pair_depth) {
    if (trace_this) {
      std::cout << "Fails avg pair depth limit\n";
    }
    discard(std::move(a));
    return;
  }

  if (min_pair_depth < m_options.min_pair_depth) {
    if (trace_this) {
      std::cout << "Fails min pair depth limit\n";
    }
    discard(std::move(a));
    return;
  }

  if (min_depth < m_options.min_read_depth) {
    if (trace_this) {
      std::cout << "Fails min read depth limit\n";
    }
    discard(std::move(a));
    return;
  }

  if (min_pair_depth < m_options.min_pair_depth) {
    if (trace_this) {
      std::cout << "Fails min pair depth limit\n";
    }
    discard(std::move(a));
    return;
  }

  int total_depth = min_depth + a->other_depth + a->ref_depth;
  if (!total_depth) {
    if (trace_this) {
      std::cout << "No total depth present\n";
    }
    discard(std::move(a));
    return;
  }
  double min_depth_p = min_depth * 1. / total_depth;
  double alt_depth_p = a->other_depth * 1. / total_depth;
  double ref_depth_p = a->ref_depth * 1. / total_depth;

  double depth_filter_p = m_options.min_depth_portion;

  if (trace_this) {
    std::cout << "Min depth: " << min_depth_p << " alt depth: " << alt_depth_p
              << " filter p: " << depth_filter_p << "\n";
  }

  if (min_depth_p < depth_filter_p) {
    if (trace_this) {
      std::cout << "Fails depth filter percent limit\n";
    }
    // Not good enough to output.
    discard(std::move(a));
    return;
  }

  if (ref_depth_p > depth_filter_p) {
    // Hetrozygous, with ref passing the ref depth filter; output a section of reference.
    a->strand_count = 1;
    a->genotype_quality = std::min<double>(min_depth_p, ref_depth_p) / (min_depth_p + ref_depth_p);
  } else if (alt_depth_p > depth_filter_p) {
    // Compound heterozygous; other strand will be emitted in a
    // separate assembly.
    a->strand_count = 1;
    a->genotype_quality = std::min<double>(min_depth_p, alt_depth_p) / (min_depth_p + alt_depth_p);
  } else {
    // Homozygous.
    // TODO(nils): How do we deal if we don't have exactly 2 strands?
    a->strand_count = 2;
    a->genotype_quality = min_depth_p;
  }

  m_output->add(std::move(a));
}

}  // namespace variants
