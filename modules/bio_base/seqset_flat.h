#pragma once

// seqset_flat provides a representation of a seqset where the
// sequences associated with each entry are much more efficiently
// available than when calling seqset_range::sequence (even if the pop
// front cache is present).
//
// The output written by seqset_flat is not versioned, so should only
// be used to store data for use in the same run, for instance, when
// merging.

#include <boost/iterator/iterator_facade.hpp>

#include "modules/bio_base/dna_sequence.h"
#include "modules/bio_base/seqset.h"
#include "modules/io/io.h"
#include "modules/io/mem_io.h"
#include "modules/io/membuf.h"
#include "modules/io/packed_varint_vector.h"
#include "modules/io/packed_vector.h"
#include "modules/io/progress.h"

extern const product_version k_seqset_flat_version;

struct seqset_flat_metadata {
  TRANSFER_OBJECT {
    VERSION(0);
    FIELD(seqset_uuid);
  }

  std::string seqset_uuid;
};

class seqset_flat_defs {
 protected:
  static constexpr const unsigned k_rc_flag = (1 << 0);
  static constexpr const unsigned k_flag_bits = 1;

 public:
  // Maximum size of the generated flat sequence buffer.  Increasing
  // this will make the index larger, since it will have to hold
  // larger values.
  static constexpr const uint64_t k_max_flat_offset =
      (1ULL << (8 * 5 - k_flag_bits)) - 1;
};

// Builds a seqset flat file.
class seqset_flat_builder : public seqset_flat_defs {
 public:
  // Caller must ensure that the_seqset outlives this object.
  seqset_flat_builder(const seqset* the_seqset);

  void build(const spiral_file_create_state& state,
             progress_handler_t progress = null_progress_handler);

 private:
  friend class seqset_flat;
  struct trace_state;

  uint64_t add_sequence(const dna_slice& seq_part1, const dna_slice& seq_part2);
  bool claim_entry(uint64_t idx);
  void add_entry(uint64_t seqset_entry_id, uint64_t base_offset,
                 uint64_t rel_offset, bool rc, const dna_sequence& seq_buffer);
  void trace(trace_state& state);
  uint64_t process_entry(uint64_t idx);
  void finalize();

  const seqset* m_seqset = nullptr;
  seqset_range m_whole_seqset_range;

  size_t m_flat_seqs = 0;
  size_t m_seqs_offset = 0;
  uint8_t m_queued_bases = 0;
  std::mutex m_seq_mu;
  mem_io m_seqs;
  std::unique_ptr<mutable_packed_varint_vector> m_entries;

  std::unique_ptr<mutable_packed_vector<unsigned, 1>> m_claimed_entries;
};

// Allows reading from a seqset_flat file originally generated by
// seqset_flat_builder.
class seqset_flat : public seqset_flat_defs {
 public:
  // Caller is responsible for ensuring that the_seqset outlives this object.
  seqset_flat(const spiral_file_open_state& state, const seqset* the_seqset);

  size_t size() const { return m_seqset->size(); }
  dna_slice get(uint64_t index) const;

  const seqset* get_seqset() const { return m_seqset; }

  class iterator
      : public boost::iterator_facade<
            iterator, dna_slice, std::random_access_iterator_tag, dna_slice> {
   public:
    iterator(const seqset_flat* flat, uint64_t pos)
        : m_flat(flat), m_pos(pos) {}
    dna_slice dereference() const { return m_flat->get(m_pos); }
    bool equal(const iterator& rhs) const {
      return m_flat == rhs.m_flat && m_pos == rhs.m_pos;
    }
    void advance(int64_t diff) { m_pos += diff; }
    void increment() { m_pos++; }
    void decrement() { m_pos--; }
    int64_t distance_to(const iterator& rhs) const { return rhs.m_pos - m_pos; }

   private:
    const seqset_flat* m_flat;
    uint64_t m_pos;
  };

  iterator begin() const { return iterator(this, 0); }
  iterator end() const { return iterator(this, size()); }

 private:
  const seqset* m_seqset = nullptr;
  membuf m_seqs;
  std::unique_ptr<packed_varint_vector> m_entries;
  seqset_flat_metadata m_metadata;
};

inline dna_slice seqset_flat::get(uint64_t index) const {
  uint64_t seqs_offset_with_flags = m_entries->get(index);

  bool rc = seqs_offset_with_flags & k_rc_flag;
  uint64_t seqs_offset = seqs_offset_with_flags >> k_flag_bits;

  unsigned len = m_seqset->entry_size(index);
  if (rc) {
    CHECK_LE(seqs_offset, m_seqs.size() * 4);
    CHECK_GE(seqs_offset + 1, len);
  } else {
    CHECK_LE(seqs_offset + len, m_seqs.size() * 4);
  }
  const char* dna_data = m_seqs.data();

  return dna_slice(
      dna_const_iterator((unsigned char*)dna_data, (ptrdiff_t)seqs_offset, rc),
      len);
}
